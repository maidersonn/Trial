/// <reference types="node" />
import type { AsyncLocalStorage } from 'async_hooks';
export declare type JsonObject<T = {}> = T & {
    [Key in string]?: JsonValue<T>;
};
export declare type JsonValue<T> = Array<JsonValue<T>> | JsonObject<T> | boolean | number | string | null;
export declare type LogWriter = (message: string) => void;
export declare type MessageContext<T = {}> = JsonObject<T>;
export declare type TopLevelAsyncLocalContext = {
    messageContext: MessageContext;
    transforms: ReadonlyArray<TransformMessageFunction<MessageContext>>;
};
export declare type NestedAsyncLocalContext = TopLevelAsyncLocalContext & {
    sequence: number;
    sequenceRoot: string;
};
export declare type AsyncLocalContext = NestedAsyncLocalContext | TopLevelAsyncLocalContext;
export declare type MessageSerializer = (message: Message<MessageContext>) => string;
export declare type RoarrGlobalState = {
    asyncLocalStorage?: AsyncLocalStorage<AsyncLocalContext>;
    sequence: number;
    serializeMessage?: MessageSerializer;
    versions: readonly string[];
    write: LogWriter;
};
export declare type SprintfArgument = boolean | number | string | null;
export declare type Message<T = MessageContext> = {
    readonly context: T;
    readonly message: string;
    readonly sequence: string;
    readonly time: number;
    readonly version: string;
};
export declare type TransformMessageFunction<T> = (message: Message<T>) => Message<MessageContext>;
export declare type LogMethod<Z> = {
    (context: Z, message: string, c?: SprintfArgument, d?: SprintfArgument, e?: SprintfArgument, f?: SprintfArgument, g?: SprintfArgument, h?: SprintfArgument, i?: SprintfArgument, j?: SprintfArgument): void;
    (message: string, b?: SprintfArgument, c?: SprintfArgument, d?: SprintfArgument, e?: SprintfArgument, f?: SprintfArgument, g?: SprintfArgument, h?: SprintfArgument, i?: SprintfArgument, j?: SprintfArgument): void;
};
declare type Child<Z> = {
    <T = Z>(context: TransformMessageFunction<MessageContext<T>>): Logger<T | Z>;
    (context: MessageContext): Logger<Z>;
};
export declare type Logger<Z = MessageContext> = LogMethod<Z> & {
    adopt: <T>(routine: () => T, context?: MessageContext | TransformMessageFunction<MessageContext>) => Promise<T>;
    child: Child<Z>;
    debug: LogMethod<Z>;
    error: LogMethod<Z>;
    fatal: LogMethod<Z>;
    getContext: () => MessageContext;
    info: LogMethod<Z>;
    trace: LogMethod<Z>;
    warn: LogMethod<Z>;
};
export declare type MessageEventHandler = (message: Message<MessageContext>) => void;
export declare type LogLevelName = 'trace' | 'debug' | 'info' | 'error' | 'fatal' | 'warn';
export {};
